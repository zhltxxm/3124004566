学习笔记
数据库操作

创建数据库 :  create database [if not exists] 数据库名;
create table [if not exists] `表名`(
    '字段名1' 列类型 [属性][索引][注释],
    '字段名2' 列类型 [属性][索引][注释],
    #...
    '字段名n' 列类型 [属性][索引][注释]
)[表类型][表字符集][注释];

删除数据库 : drop database [if exists] 数据库名;
查看数据库 : show databases;
使用数据库 : use 数据库名;


修改数据库

修改表 ( ALTER TABLE )
修改表名 :ALTER TABLE 旧表名 RENAME AS 新表名
添加字段 : ALTER TABLE 表名 ADD字段名 列属性[属性]
修改字段 : ALTER TABLE 表名 MODIFY 字段名 列类型[属性]
          ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性]
删除字段 :  ALTER TABLE 表名 DROP 字段名

删除数据表
语法：DROP TABLE [IF EXISTS] 表名
IF EXISTS为可选 , 判断是否存在该数据表,如删除不存在的数据表会抛出错误


创建外键
-- 创建外键的方式一 : 创建子表同时创建外键

-- 年级表 (id\年级名称)
CREATE TABLE `grade` (
  `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级ID',
  `gradename` VARCHAR(50) NOT NULL COMMENT '年级名称',
  PRIMARY KEY (`gradeid`)
) ENGINE=INNODB DEFAULT CHARSET=utf8

-- 创建外键方式二 : 创建子表完毕后,修改子表添加外键
ALTER TABLE `student`
ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`);

删除外键
ALTER TABLE student DROP FOREIGN KEY FK_gradeid;
-- 发现执行完上面的,索引还在,所以还要删除索引
-- 注:这个索引是建立外键的时候默认生成的
ALTER TABLE student DROP INDEX FK_gradeid;

===================================================
DML语言

添加数据
INSERT命令
语法：INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3')

修改数据
update命令
语法：UPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHERE condition];注意 : column_name 为要更改的数据列value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果condition 为筛选条件 , 如不指定则修改该表的所有列数据

UPDATE grade SET gradename = '高中' WHERE gradeid = 1;

删除数据
DELETE命令
语法：DELETE FROM 表名 [WHERE condition];注意：condition为筛选条件 , 如不指定则删除该表的所有列数据-- 删除最后一个数据
DELETE FROM grade WHERE gradeid = 5

TRUNCATE命令
作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ;
语法：TRUNCATE [TABLE] table_name;

-- 清空年级表
TRUNCATE grade
注意：区别于DELETE命令相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快
不同 :使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器使用
      TRUNCATE TABLE不会对事务有影响

========================================================
DQL语言

AS 子句作为别名

SELECT语法SELECT [ALL | DISTINCT]
{* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]}
FROM table_name [as table_alias]
    [left | right | inner join table_name2]  -- 联合查询
    [WHERE ...]  -- 指定结果需满足的条件
    [GROUP BY ...]  -- 指定结果按照哪几个字段来分组
    [HAVING]  -- 过滤分组的记录必须满足的次要条件
    [ORDER BY ...]  -- 指定查询记录按一个或多个条件排序
    [LIMIT {[offset,]row_count | row_countOFFSET offset}];
    --  指定查询的记录从哪条至哪条

连接查询
    如需要多张数据表的数据进行查询,则可通过连接运算符实现多个查询
内连接 inner join
    查询两个表中的结果集中的交集
外连接 outer join
    左外连接 left join
        (以左表作为基准,右边表来一一匹配,匹配不上的,返回左表的记录,右表以NULL填充)
    右外连接 right join
        (以右表作为基准,左边表来一一匹配,匹配不上的,返回右表的记录,左表以NULL填充)

排序和分页测试/*============== 排序 ================
语法 : ORDER BY
    ORDER BY 语句用于根据指定的列对结果集进行排序。
    ORDER BY 语句默认按照ASC升序对记录进行排序。
    如果希望按照降序对记录进行排序，可以使用 DESC 关键字。

子查询

==============================================================
// ========== 数据库工具类 ==========
import java.sql.*;
import java.io.IOException;
import java.io.InputStream;
public class DBUtil {
    //注册
    private static final String URL = "jdbc:mysql://localhost:3306/school?useUnicode=true&characterEncoding=utf8&useSSL=true";
    private static final String USER = "root";
    private static final String PASSWORD = "Zhl060903@";

    // 获取数据库连接
    public static Connection getConnection() throws SQLException {
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (Exception e) {
            //throw new SQLException("驱动加载失败");
            e.printStackTrace();
        }
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }

    // 关闭资源
    public static void close(Connection conn, Statement stmt, ResultSet rs) {
        try {
            if (rs != null) rs.close();
            if (stmt != null) stmt.close();
            if (conn != null) conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}








































































